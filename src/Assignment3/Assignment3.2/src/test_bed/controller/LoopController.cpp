/**********************************************************
 * This file is generated by the 20-sim C++ Code Generator
 *
 *  file:  LoopController.cpp
 *  subm:  LoopController
 *  model: RELbotSimple
 *  expmt: RELbotSimple
 *  date:  April 2, 2025
 *  time:  10:35:55 AM
 *  user:  Vakgroep RaM
 *  from:  -
 *  build: 5.1.4.13773
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <math.h>
/* Include the header for memcpy and memset
 * You may need to change this into <memory.h> for older compilers
 */
#include <string.h>

/* 20-sim include files */
#include "LoopController.h"

/* Delta margin used for end time checking */
const XXDouble c_delta = 1.0e-7;

/* this PRIVATE function sets the input variables from the input vector */
void LoopController::CopyInputsToVariables (XXDouble *u)
{
	/* copy the input vector to the input variables */
	m_V[0] = u[0];		/* SetVelLeft */
	m_V[2] = u[1];		/* SetVelRight */

}

/* this PRIVATE function uses the output variables to fill the output vector */
void LoopController::CopyVariablesToOutputs (XXDouble *y)
{
	/* copy the output variables to the output vector */
	y[0] = 	m_V[1];		/* SteerLeft */
	y[1] = 	m_V[3];		/* SteerRight */

}

LoopController::LoopController(void)
{
	m_number_constants = 0;
	m_number_parameters = 0;
	m_number_initialvalues = 0;
	m_number_variables = 4;
	m_number_states = 0;
	m_number_rates = 0;
	m_number_matrices = 0;
	m_number_unnamed = 0;

	/* the variable arrays */
	m_C = new XXDouble[0 + 1];		/* constants */
	m_P = new XXDouble[0 + 1];		/* parameters */
	m_I = new XXDouble[0 + 1];		/* initial values */
	m_V = new XXDouble[4 + 1];		/* variables */
	m_s = new XXDouble[0 + 1];		/* states */
	m_R = new XXDouble[0 + 1];		/* rates (or new states) */
	m_M = new XXMatrix[0 + 1];		/* matrices */
	m_U = new XXDouble[0 + 1];		/* unnamed */
	m_workarray = new XXDouble[0 + 1];

	Reset(0.0);
	m_finish_time = 10.0;
}

void LoopController::Reset(XXDouble starttime)
{
	m_start_time = starttime;
	m_step_size = 0.01;
	m_time = starttime;
	m_major = true;
	m_stop_run = false;

	/* Clear the allocated variable memory */
	memset(m_C, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_P, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_I, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_V, 0, (4 + 1) * sizeof(XXDouble));
	memset(m_s, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_R, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_M, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_U, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_workarray, 0, (0 + 1) * sizeof(XXDouble));


	state = initialrun;
}

bool LoopController::IsFinished(void)
{
	return (state == finished);
}

LoopController::~LoopController(void)
{
	/* free memory */
	delete[] m_C;
	delete[] m_P;
	delete[] m_I;
	delete[] m_V;
	delete[] m_s;
	delete[] m_R;
	delete[] m_M;
	delete[] m_U;
	delete[] m_workarray;
}

/* the initialization function for submodel */
void LoopController::Initialize (XXDouble *u, XXDouble *y, XXDouble t)
{
	/* initialization phase (allocating memory) */
	m_initialize = true;
	m_stop_run = false;

	/* set the constants */


	/* set the parameters */


	/* set the initial values */


	/* set the states */


	/* set the matrices */


	/* (re-)initialize the integration method */
	myintegmethod.Initialize(this);
	
	/* copy the inputs */
	m_time = t;
	CopyInputsToVariables (u);

	/* calculate initial equations */
	CalculateInitial ();

	/* set the states again, they might have changed in the initial calculation */


	/* calculate static equations */
	CalculateStatic ();
	/* calculate input equations */
	CalculateInput ();
	/* calculate dynamic equations */
	CalculateDynamic ();
	/* calculate output equations */
	CalculateOutput ();

	/* Set the outputs */
	CopyVariablesToOutputs (y);

	/* end of initialization phase */
	m_initialize = false;

	state = mainrun;
}

/* the function that calculates the submodel */
void LoopController::Calculate (XXDouble *u, XXDouble *y /*, XXDouble t*/)
{
	switch (state)
	{
		case initialrun:	/* calculate the model for the first time */
			Initialize(u, y, 0.0);
			break;
		case mainrun:	/* calculate the model */
			if ( ( m_time <= (m_finish_time - m_step_size  + c_delta )) || ( m_finish_time == 0.0 ) )
			{
				/* another precessor submodel could determine the parameters of this submodel
				   and therefore the static parameter calculations need to be performed. */
				CalculateStatic ();
				CopyInputsToVariables (u);
				CalculateInput ();
				myintegmethod.Step();
				CalculateOutput ();
				CopyVariablesToOutputs (y);
			}
			else
			{
				state = finished;
			}

			if ( ( m_stop_run == true ) || (( m_finish_time != 0.0 ) && ( m_time + c_delta >= m_finish_time)) )
			{
				state = finished;
			}
			break;
		case finished:
			break;
		default:
			break;
	}
}

/* the termination function for submodel */
void LoopController::Terminate (XXDouble *u, XXDouble *y /*, XXDouble t */)
{
	/* copy the inputs */
	CopyInputsToVariables (u);

	/* calculate the final model equations */
	CalculateFinal ();

	/* set the outputs */
	CopyVariablesToOutputs (y);
}


/* This function calculates the initial equations of the model.
 * These equations are calculated before anything else
 */
void LoopController::CalculateInitial (void)
{

}

/* This function calculates the static equations of the model.
 * These equations are only dependent from parameters and constants
 */
void LoopController::CalculateStatic (void)
{

}

/* This function calculates the input equations of the model.
 * These equations are dynamic equations that must not change
 * in calls from the integration method (like random and delay).
 */
void LoopController::CalculateInput (void)
{

}

/* This function calculates the dynamic equations of the model.
 * These equations are called from the integration method
 * to calculate the new model rates (that are then integrated).
 */
void LoopController::CalculateDynamic (void)
{
	/* SteerLeft = SetVelLeft; */
	m_V[1] = m_V[0];

	/* SteerRight = SetVelRight; */
	m_V[3] = m_V[2];

}

/* This function calculates the output equations of the model.
 * These equations are not needed for calculation of the rates
 * and are kept separate to make the dynamic set of equations smaller.
 * These dynamic equations are called often more than one time for each
 * integration step that is taken. This makes model computation much faster.
 */
void LoopController::CalculateOutput (void)
{

}

/* This function calculates the final equations of the model.
 * These equations are calculated after all the calculations
 * are performed
 */
void LoopController::CalculateFinal (void)
{

}



bool LoopController::SetFinishTime(XXDouble newtime)
{
	if ((newtime <= 0.0) || ( newtime > m_time))
	{
		m_finish_time = newtime;
		return true;
	}

	return false;
}

